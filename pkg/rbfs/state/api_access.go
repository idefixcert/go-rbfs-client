/*
 * RBFS Operational State API
 *
 * This contract describes the RBFS Operational State API contract defined by RBMS, the RtBrick Management System. This API is a _consumer-driven_ API, which means that all changes to this API **must be approved** by RBMS, the consumer of this API to avoid compatibility issues.  The API is kept backwards-compatible and anyone is allowed to _use_ this API.  The consumer of the API _must_ ignore additional attributes not explained in this specification. Additional attributes are _not_ considered violating backwards compatibility. In contrary, additional attributes allow extending the API while preserving backward compatibility.
 *
 * API version: 1.0.0
 * Contact: martin@rtbrick.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package state

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type AccessApiService service

/*
AccessApiService Adds a VLAN profile.
Injects a single VLAN profile object into the global VLAN profile BDS table.  A VLAN profile has a composite key of up to 5 parameters, which are modelled as query parameters because of the many valid combinations. The keys specified in the VLAN profile must match the query parameters. Otherwise the request gets rejected.  This endpoint creates a VLAN profile object from the specified keys when no VLAN profile is specified.  This is a convenience function to simplify creation of VLAN profiles that consists of key attributes only.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param ifpName The physical interface.
 * @param optional nil or *AccessApiAddVLANProfileOpts - Optional Parameters:
     * @param "OuterVlanMin" (optional.Int) -  The outer VLAN range minimum value.
     * @param "OuterVlanMax" (optional.Int) -  The outer VLAN range maximum value.
     * @param "InnerVlanMin" (optional.Int) -  The inner VLAN range minimum value.
     * @param "InnerVlanMax" (optional.Int) -  The inner VLAN range maximum value.

*/

type AccessApiAddVLANProfileOpts struct {
	OuterVlanMin optional.Int
	OuterVlanMax optional.Int
	InnerVlanMin optional.Int
	InnerVlanMax optional.Int
}

func (a *AccessApiService) AddVLANProfile(ctx context.Context, body VlanProfile, ifpName string, localVarOptionals *AccessApiAddVLANProfileOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/access/vlan-profiles/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("ifp_name", parameterToString(ifpName, ""))
	if localVarOptionals != nil && localVarOptionals.OuterVlanMin.IsSet() {
		localVarQueryParams.Add("outer_vlan_min", parameterToString(localVarOptionals.OuterVlanMin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OuterVlanMax.IsSet() {
		localVarQueryParams.Add("outer_vlan_max", parameterToString(localVarOptionals.OuterVlanMax.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InnerVlanMin.IsSet() {
		localVarQueryParams.Add("inner_vlan_min", parameterToString(localVarOptionals.InnerVlanMin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InnerVlanMax.IsSet() {
		localVarQueryParams.Add("inner_vlan_max", parameterToString(localVarOptionals.InnerVlanMax.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
AccessApiService Deletes a VLAN profile.
Deletes a single VLAN profile object from the global VLAN profile BDS table. Performs an exact match on the query parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ifpName The physical interface.
 * @param optional nil or *AccessApiDeleteVLANProfileOpts - Optional Parameters:
     * @param "OuterVlanMin" (optional.Int) -  The outer VLAN range minimum value.
     * @param "OuterVlanMax" (optional.Int) -  The outer VLAN range maximum value.
     * @param "InnerVlanMin" (optional.Int) -  The inner VLAN range minimum value.
     * @param "InnerVlanMax" (optional.Int) -  The inner VLAN range maximum value.

*/

type AccessApiDeleteVLANProfileOpts struct {
	OuterVlanMin optional.Int
	OuterVlanMax optional.Int
	InnerVlanMin optional.Int
	InnerVlanMax optional.Int
}

func (a *AccessApiService) DeleteVLANProfile(ctx context.Context, ifpName string, localVarOptionals *AccessApiDeleteVLANProfileOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/access/vlan-profiles/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("ifp_name", parameterToString(ifpName, ""))
	if localVarOptionals != nil && localVarOptionals.OuterVlanMin.IsSet() {
		localVarQueryParams.Add("outer_vlan_min", parameterToString(localVarOptionals.OuterVlanMin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OuterVlanMax.IsSet() {
		localVarQueryParams.Add("outer_vlan_max", parameterToString(localVarOptionals.OuterVlanMax.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InnerVlanMin.IsSet() {
		localVarQueryParams.Add("inner_vlan_min", parameterToString(localVarOptionals.InnerVlanMin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InnerVlanMax.IsSet() {
		localVarQueryParams.Add("inner_vlan_max", parameterToString(localVarOptionals.InnerVlanMax.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
AccessApiService Deletes VLAN profiles.
Deletes all VLAN profile objects, optionally filtered by the physical interface.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AccessApiFlushVLANProfilesOpts - Optional Parameters:
     * @param "IfpName" (optional.String) -  The physical interface.

*/

type AccessApiFlushVLANProfilesOpts struct {
	IfpName optional.String
}

func (a *AccessApiService) FlushVLANProfiles(ctx context.Context, localVarOptionals *AccessApiFlushVLANProfilesOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/access/vlan-profiles/flush"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IfpName.IsSet() {
		localVarQueryParams.Add("ifp_name", parameterToString(localVarOptionals.IfpName.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
AccessApiService Lists VLAN profiles
Lists all VLAN profiles, optionally filtered by physical interface.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AccessApiGetVLANProfilesOpts - Optional Parameters:
     * @param "IfpName" (optional.String) -  The physical interface name.
@return []VlanProfile
*/

type AccessApiGetVLANProfilesOpts struct {
	IfpName optional.String
}

func (a *AccessApiService) GetVLANProfiles(ctx context.Context, localVarOptionals *AccessApiGetVLANProfilesOpts) ([]VlanProfile, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []VlanProfile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/access/vlan-profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IfpName.IsSet() {
		localVarQueryParams.Add("ifp_name", parameterToString(localVarOptionals.IfpName.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []VlanProfile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
AccessApiService Runs a VLAN profile configuration batch job.
Stores and removes all VLAN profiles as specified in the batch.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
*/
func (a *AccessApiService) ProcessVLANProfilesBatch(ctx context.Context, body VlanProfileBatch) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/access/vlan-profiles/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
AccessApiService Updates VLAN profiles.
Creates or replaces all VLAN profiles with the list of profiles in the request body, optionally filtered by the physical interface.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body List of VLAN profile objects.
 * @param optional nil or *AccessApiStoreVLANProfilesOpts - Optional Parameters:
     * @param "IfpName" (optional.String) -  The physical interface name.

*/

type AccessApiStoreVLANProfilesOpts struct {
	IfpName optional.String
}

func (a *AccessApiService) StoreVLANProfiles(ctx context.Context, body []VlanProfile, localVarOptionals *AccessApiStoreVLANProfilesOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/access/vlan-profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IfpName.IsSet() {
		localVarQueryParams.Add("ifp_name", parameterToString(localVarOptionals.IfpName.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
